import sqlite3
connection = sqlite3.connect("pantherpals.db")
query = connection.cursor()

table_definitions = {
  'announcement': ['title', 'text'],
  'user': ['name', 'pronouns']
}

# Set up all database tables
def setup_db():
  for table_name, attributes in table_definitions.items():
    query_string = f'''
      CREATE TABLE IF NOT EXISTS {table_name} (
        id INTEGER PRIMARY KEY,
        {
          ', '.join([f'{attribute} TEXT' for attribute in attributes])
        }
      );
    '''
    
    query.execute(query_string)
    connection.commit()

# Insert to given table
#
# table (string) - the name of the class being saved, all lowercase
# data (dict) - the data to be saved for an instance of the class
#   - each key should be an attribute name
#   - corresponding values should be attribute values
#   - there is no need to supply an ID or UUID.  ID will be autogenerated
def create(table, data):
  data_keys = ",".join(list(data.keys()))
  data_values = ','.join([f'"{value}"' for value in list(data.values())])
  query_string = f'''
    INSERT INTO {table} (
      {data_keys}
    ) VALUES (
      {data_values}
    );
  '''
  query.execute(query_string)
  connection.commit()


# Update a record in a given table
#
# table (string) - the name of the class being updated, all lowercase
# data (dict)- the specific attributes to be updated
#   - each key should be an attribute name
#   - corresponding values should be new attribute values for this record
# condition (dict) - conditions(s) specifying which record(s) to update.  At least one key/value pair should be provided
#   - each key should be an attribute name
#   - corresponding values should be attribute value to be matched against
# *NOTE* if checking a condition other than ID, it is possible to update multiple records at once.
def update(table, data, condition):
  data_string = ' AND '.join([
    f'{data_key} = "{data_value}"' 
    for data_key, data_value 
    in data.items()
  ])
  
  condition_string = ' AND '.join([
    f'{condition_key} = "{condition_value}"' 
    for condition_key, condition_value 
    in condition.items()
  ])

  query_string = f'''
    UPDATE {table}
    SET {data_string}
    WHERE {condition_string}
  '''
  
  query.execute(query_string)
  connection.commit()

# Read one or more records of a given class
#
# table (string) - the name of the class being read, all lowercase
# attributes (list of strings) - the attributes to be fetched, or all if not included
# condition (dict) - conditions(s) specifying which record(s) to update.  If no condition is provided, all results will be returned
#   - each key should be an attribute name
#   - corresponding values should be attribute value to be matched against
# order_by (dict) - indicates a specific order to return results in.  If no order_by is provided, results will return in default order
#   - key should be an attribute name
#   - corresponding value should be either 'ASC' or 'DESC'
# limit (int) - maximum number of records to return.  If no limit is provided, all matching records will be returned.
def read(table, attributes = None, condition = None, order_by = None, limit = None):
  attributes_string =  '*' if attributes == None else ','.join(attributes)
  
  condition_string = '' if condition == None else 'WHERE ' + ' AND '.join([
    f'{condition_key} = "{condition_value}"' 
    for condition_key, condition_value 
    in condition.items()
  ])
  
  order_by_string = '' if order_by == None else 'ORDER BY ' + ', '.join([
    f'{order_by_key} {order_by_value}'
    for order_by_key, order_by_value
    in order_by.items()
  ])
  
  limit_string = '' if limit == None else 'LIMIT ' + str(limit)

  query_string = f'''
    SELECT {attributes_string}
    FROM {table}
    {condition_string}
    {order_by_string}
    {limit_string}
  '''

  query.execute(query_string)
  results = query.fetchall()

  return results
  
setup_db()
